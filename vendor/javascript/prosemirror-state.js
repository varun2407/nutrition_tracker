// prosemirror-state@1.4.3 downloaded from https://ga.jspm.io/npm:prosemirror-state@1.4.3/dist/index.js

import{Slice as e,Fragment as t,Mark as n,Node as r}from"prosemirror-model";import{ReplaceStep as i,ReplaceAroundStep as o,Transform as s}from"prosemirror-transform";const l=Object.create(null);class Selection{constructor(e,t,n){this.$anchor=e;this.$head=t;this.ranges=n||[new SelectionRange(e.min(t),e.max(t))]}get anchor(){return this.$anchor.pos}get head(){return this.$head.pos}get from(){return this.$from.pos}get to(){return this.$to.pos}get $from(){return this.ranges[0].$from}get $to(){return this.ranges[0].$to}get empty(){let e=this.ranges;for(let t=0;t<e.length;t++)if(e[t].$from.pos!=e[t].$to.pos)return false;return true}content(){return this.$from.doc.slice(this.from,this.to,true)}replace(t,n=e.empty){let r=n.content.lastChild,i=null;for(let e=0;e<n.openEnd;e++){i=r;r=r.lastChild}let o=t.steps.length,s=this.ranges;for(let l=0;l<s.length;l++){let{$from:c,$to:a}=s[l],h=t.mapping.slice(o);t.replaceRange(h.map(c.pos),h.map(a.pos),l?e.empty:n);0==l&&selectionToInsertionEnd(t,o,(r?r.isInline:i&&i.isTextblock)?-1:1)}}replaceWith(e,t){let n=e.steps.length,r=this.ranges;for(let i=0;i<r.length;i++){let{$from:o,$to:s}=r[i],l=e.mapping.slice(n);let c=l.map(o.pos),a=l.map(s.pos);if(i)e.deleteRange(c,a);else{e.replaceRangeWith(c,a,t);selectionToInsertionEnd(e,n,t.isInline?-1:1)}}}static findFrom(e,t,n=false){let r=e.parent.inlineContent?new TextSelection(e):findSelectionIn(e.node(0),e.parent,e.pos,e.index(),t,n);if(r)return r;for(let r=e.depth-1;r>=0;r--){let i=t<0?findSelectionIn(e.node(0),e.node(r),e.before(r+1),e.index(r),t,n):findSelectionIn(e.node(0),e.node(r),e.after(r+1),e.index(r)+1,t,n);if(i)return i}return null}static near(e,t=1){return this.findFrom(e,t)||this.findFrom(e,-t)||new AllSelection(e.node(0))}static atStart(e){return findSelectionIn(e,e,0,0,1)||new AllSelection(e)}static atEnd(e){return findSelectionIn(e,e,e.content.size,e.childCount,-1)||new AllSelection(e)}static fromJSON(e,t){if(!t||!t.type)throw new RangeError("Invalid input for Selection.fromJSON");let n=l[t.type];if(!n)throw new RangeError(`No selection type ${t.type} defined`);return n.fromJSON(e,t)}static jsonID(e,t){if(e in l)throw new RangeError("Duplicate use of selection JSON ID "+e);l[e]=t;t.prototype.jsonID=e;return t}getBookmark(){return TextSelection.between(this.$anchor,this.$head).getBookmark()}}Selection.prototype.visible=true;class SelectionRange{constructor(e,t){this.$from=e;this.$to=t}}let c=false;function checkTextSelection(e){if(!c&&!e.parent.inlineContent){c=true;console.warn("TextSelection endpoint not pointing into a node with inline content ("+e.parent.type.name+")")}}class TextSelection extends Selection{constructor(e,t=e){checkTextSelection(e);checkTextSelection(t);super(e,t)}get $cursor(){return this.$anchor.pos==this.$head.pos?this.$head:null}map(e,t){let n=e.resolve(t.map(this.head));if(!n.parent.inlineContent)return Selection.near(n);let r=e.resolve(t.map(this.anchor));return new TextSelection(r.parent.inlineContent?r:n,n)}replace(t,n=e.empty){super.replace(t,n);if(n==e.empty){let e=this.$from.marksAcross(this.$to);e&&t.ensureMarks(e)}}eq(e){return e instanceof TextSelection&&e.anchor==this.anchor&&e.head==this.head}getBookmark(){return new TextBookmark(this.anchor,this.head)}toJSON(){return{type:"text",anchor:this.anchor,head:this.head}}static fromJSON(e,t){if("number"!=typeof t.anchor||"number"!=typeof t.head)throw new RangeError("Invalid input for TextSelection.fromJSON");return new TextSelection(e.resolve(t.anchor),e.resolve(t.head))}static create(e,t,n=t){let r=e.resolve(t);return new this(r,n==t?r:e.resolve(n))}static between(e,t,n){let r=e.pos-t.pos;n&&!r||(n=r>=0?1:-1);if(!t.parent.inlineContent){let e=Selection.findFrom(t,n,true)||Selection.findFrom(t,-n,true);if(!e)return Selection.near(t,n);t=e.$head}if(!e.parent.inlineContent)if(0==r)e=t;else{e=(Selection.findFrom(e,-n,true)||Selection.findFrom(e,n,true)).$anchor;e.pos<t.pos!=r<0&&(e=t)}return new TextSelection(e,t)}}Selection.jsonID("text",TextSelection);class TextBookmark{constructor(e,t){this.anchor=e;this.head=t}map(e){return new TextBookmark(e.map(this.anchor),e.map(this.head))}resolve(e){return TextSelection.between(e.resolve(this.anchor),e.resolve(this.head))}}class NodeSelection extends Selection{constructor(e){let t=e.nodeAfter;let n=e.node(0).resolve(e.pos+t.nodeSize);super(e,n);this.node=t}map(e,t){let{deleted:n,pos:r}=t.mapResult(this.anchor);let i=e.resolve(r);return n?Selection.near(i):new NodeSelection(i)}content(){return new e(t.from(this.node),0,0)}eq(e){return e instanceof NodeSelection&&e.anchor==this.anchor}toJSON(){return{type:"node",anchor:this.anchor}}getBookmark(){return new NodeBookmark(this.anchor)}static fromJSON(e,t){if("number"!=typeof t.anchor)throw new RangeError("Invalid input for NodeSelection.fromJSON");return new NodeSelection(e.resolve(t.anchor))}static create(e,t){return new NodeSelection(e.resolve(t))}static isSelectable(e){return!e.isText&&false!==e.type.spec.selectable}}NodeSelection.prototype.visible=false;Selection.jsonID("node",NodeSelection);class NodeBookmark{constructor(e){this.anchor=e}map(e){let{deleted:t,pos:n}=e.mapResult(this.anchor);return t?new TextBookmark(n,n):new NodeBookmark(n)}resolve(e){let t=e.resolve(this.anchor),n=t.nodeAfter;return n&&NodeSelection.isSelectable(n)?new NodeSelection(t):Selection.near(t)}}class AllSelection extends Selection{constructor(e){super(e.resolve(0),e.resolve(e.content.size))}replace(t,n=e.empty){if(n==e.empty){t.delete(0,t.doc.content.size);let e=Selection.atStart(t.doc);e.eq(t.selection)||t.setSelection(e)}else super.replace(t,n)}toJSON(){return{type:"all"}}static fromJSON(e){return new AllSelection(e)}map(e){return new AllSelection(e)}eq(e){return e instanceof AllSelection}getBookmark(){return a}}Selection.jsonID("all",AllSelection);const a={map(){return this},resolve(e){return new AllSelection(e)}};function findSelectionIn(e,t,n,r,i,o=false){if(t.inlineContent)return TextSelection.create(e,n);for(let s=r-(i>0?0:1);i>0?s<t.childCount:s>=0;s+=i){let r=t.child(s);if(r.isAtom){if(!o&&NodeSelection.isSelectable(r))return NodeSelection.create(e,n-(i<0?r.nodeSize:0))}else{let t=findSelectionIn(e,r,n+i,i<0?r.childCount:0,i,o);if(t)return t}n+=r.nodeSize*i}return null}function selectionToInsertionEnd(e,t,n){let r=e.steps.length-1;if(r<t)return;let s=e.steps[r];if(!(s instanceof i||s instanceof o))return;let l,c=e.mapping.maps[r];c.forEach(((e,t,n,r)=>{null==l&&(l=r)}));e.setSelection(Selection.near(e.doc.resolve(l),n))}const h=1,u=2,d=4;class Transaction extends s{constructor(e){super(e.doc);this.curSelectionFor=0;this.updated=0;this.meta=Object.create(null);this.time=Date.now();this.curSelection=e.selection;this.storedMarks=e.storedMarks}get selection(){if(this.curSelectionFor<this.steps.length){this.curSelection=this.curSelection.map(this.doc,this.mapping.slice(this.curSelectionFor));this.curSelectionFor=this.steps.length}return this.curSelection}setSelection(e){if(e.$from.doc!=this.doc)throw new RangeError("Selection passed to setSelection must point at the current document");this.curSelection=e;this.curSelectionFor=this.steps.length;this.updated=(this.updated|h)&~u;this.storedMarks=null;return this}get selectionSet(){return(this.updated&h)>0}setStoredMarks(e){this.storedMarks=e;this.updated|=u;return this}ensureMarks(e){n.sameSet(this.storedMarks||this.selection.$from.marks(),e)||this.setStoredMarks(e);return this}addStoredMark(e){return this.ensureMarks(e.addToSet(this.storedMarks||this.selection.$head.marks()))}removeStoredMark(e){return this.ensureMarks(e.removeFromSet(this.storedMarks||this.selection.$head.marks()))}get storedMarksSet(){return(this.updated&u)>0}addStep(e,t){super.addStep(e,t);this.updated=this.updated&~u;this.storedMarks=null}setTime(e){this.time=e;return this}replaceSelection(e){this.selection.replace(this,e);return this}replaceSelectionWith(e,t=true){let r=this.selection;t&&(e=e.mark(this.storedMarks||(r.empty?r.$from.marks():r.$from.marksAcross(r.$to)||n.none)));r.replaceWith(this,e);return this}deleteSelection(){this.selection.replace(this);return this}insertText(e,t,n){let r=this.doc.type.schema;if(null==t)return e?this.replaceSelectionWith(r.text(e),true):this.deleteSelection();{null==n&&(n=t);n=null==n?t:n;if(!e)return this.deleteRange(t,n);let i=this.storedMarks;if(!i){let e=this.doc.resolve(t);i=n==t?e.marks():e.marksAcross(this.doc.resolve(n))}this.replaceRangeWith(t,n,r.text(e,i));this.selection.empty||this.setSelection(Selection.near(this.selection.$to));return this}}setMeta(e,t){this.meta["string"==typeof e?e:e.key]=t;return this}getMeta(e){return this.meta["string"==typeof e?e:e.key]}get isGeneric(){for(let e in this.meta)return false;return true}scrollIntoView(){this.updated|=d;return this}get scrolledIntoView(){return(this.updated&d)>0}}function bind(e,t){return t&&e?e.bind(t):e}class FieldDesc{constructor(e,t,n){this.name=e;this.init=bind(t.init,n);this.apply=bind(t.apply,n)}}const p=[new FieldDesc("doc",{init(e){return e.doc||e.schema.topNodeType.createAndFill()},apply(e){return e.doc}}),new FieldDesc("selection",{init(e,t){return e.selection||Selection.atStart(t.doc)},apply(e){return e.selection}}),new FieldDesc("storedMarks",{init(e){return e.storedMarks||null},apply(e,t,n,r){return r.selection.$cursor?e.storedMarks:null}}),new FieldDesc("scrollToSelection",{init(){return 0},apply(e,t){return e.scrolledIntoView?t+1:t}})];class Configuration{constructor(e,t){this.schema=e;this.plugins=[];this.pluginsByKey=Object.create(null);this.fields=p.slice();t&&t.forEach((e=>{if(this.pluginsByKey[e.key])throw new RangeError("Adding different instances of a keyed plugin ("+e.key+")");this.plugins.push(e);this.pluginsByKey[e.key]=e;e.spec.state&&this.fields.push(new FieldDesc(e.key,e.spec.state,e))}))}}class EditorState{constructor(e){this.config=e}get schema(){return this.config.schema}get plugins(){return this.config.plugins}apply(e){return this.applyTransaction(e).state}filterTransaction(e,t=-1){for(let n=0;n<this.config.plugins.length;n++)if(n!=t){let t=this.config.plugins[n];if(t.spec.filterTransaction&&!t.spec.filterTransaction.call(t,e,this))return false}return true}applyTransaction(e){if(!this.filterTransaction(e))return{state:this,transactions:[]};let t=[e],n=this.applyInner(e),r=null;for(;;){let i=false;for(let o=0;o<this.config.plugins.length;o++){let s=this.config.plugins[o];if(s.spec.appendTransaction){let l=r?r[o].n:0,c=r?r[o].state:this;let a=l<t.length&&s.spec.appendTransaction.call(s,l?t.slice(l):t,c,n);if(a&&n.filterTransaction(a,o)){a.setMeta("appendedTransaction",e);if(!r){r=[];for(let e=0;e<this.config.plugins.length;e++)r.push(e<o?{state:n,n:t.length}:{state:this,n:0})}t.push(a);n=n.applyInner(a);i=true}r&&(r[o]={state:n,n:t.length})}}if(!i)return{state:n,transactions:t}}}applyInner(e){if(!e.before.eq(this.doc))throw new RangeError("Applying a mismatched transaction");let t=new EditorState(this.config),n=this.config.fields;for(let r=0;r<n.length;r++){let i=n[r];t[i.name]=i.apply(e,this[i.name],this,t)}return t}get tr(){return new Transaction(this)}static create(e){let t=new Configuration(e.doc?e.doc.type.schema:e.schema,e.plugins);let n=new EditorState(t);for(let r=0;r<t.fields.length;r++)n[t.fields[r].name]=t.fields[r].init(e,n);return n}reconfigure(e){let t=new Configuration(this.schema,e.plugins);let n=t.fields,r=new EditorState(t);for(let t=0;t<n.length;t++){let i=n[t].name;r[i]=this.hasOwnProperty(i)?this[i]:n[t].init(e,r)}return r}toJSON(e){let t={doc:this.doc.toJSON(),selection:this.selection.toJSON()};this.storedMarks&&(t.storedMarks=this.storedMarks.map((e=>e.toJSON())));if(e&&"object"==typeof e)for(let n in e){if("doc"==n||"selection"==n)throw new RangeError("The JSON fields `doc` and `selection` are reserved");let r=e[n],i=r.spec.state;i&&i.toJSON&&(t[n]=i.toJSON.call(r,this[r.key]))}return t}static fromJSON(e,t,n){if(!t)throw new RangeError("Invalid input for EditorState.fromJSON");if(!e.schema)throw new RangeError("Required config field 'schema' missing");let i=new Configuration(e.schema,e.plugins);let o=new EditorState(i);i.fields.forEach((i=>{if("doc"==i.name)o.doc=r.fromJSON(e.schema,t.doc);else if("selection"==i.name)o.selection=Selection.fromJSON(o.doc,t.selection);else if("storedMarks"==i.name)t.storedMarks&&(o.storedMarks=t.storedMarks.map(e.schema.markFromJSON));else{if(n)for(let r in n){let s=n[r],l=s.spec.state;if(s.key==i.name&&l&&l.fromJSON&&Object.prototype.hasOwnProperty.call(t,r)){o[i.name]=l.fromJSON.call(s,e,t[r],o);return}}o[i.name]=i.init(e,o)}}));return o}}function bindProps(e,t,n){for(let r in e){let i=e[r];i instanceof Function?i=i.bind(t):"handleDOMEvents"==r&&(i=bindProps(i,t,{}));n[r]=i}return n}class Plugin{constructor(e){this.spec=e;this.props={};e.props&&bindProps(e.props,this,this.props);this.key=e.key?e.key.key:createKey("plugin")}getState(e){return e[this.key]}}const f=Object.create(null);function createKey(e){if(e in f)return e+"$"+ ++f[e];f[e]=0;return e+"$"}class PluginKey{constructor(e="key"){this.key=createKey(e)}get(e){return e.config.pluginsByKey[this.key]}getState(e){return e[this.key]}}export{AllSelection,EditorState,NodeSelection,Plugin,PluginKey,Selection,SelectionRange,TextSelection,Transaction};

