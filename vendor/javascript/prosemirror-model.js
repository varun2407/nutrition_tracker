// prosemirror-model@1.25.0 downloaded from https://ga.jspm.io/npm:prosemirror-model@1.25.0/dist/index.js

import t from"orderedmap";function findDiffStart(t,e,n){for(let r=0;;r++){if(r==t.childCount||r==e.childCount)return t.childCount==e.childCount?null:n;let i=t.child(r),s=e.child(r);if(i!=s){if(!i.sameMarkup(s))return n;if(i.isText&&i.text!=s.text){for(let t=0;i.text[t]==s.text[t];t++)n++;return n}if(i.content.size||s.content.size){let t=findDiffStart(i.content,s.content,n+1);if(t!=null)return t}n+=i.nodeSize}else n+=i.nodeSize}}function findDiffEnd(t,e,n,r){for(let i=t.childCount,s=e.childCount;;){if(i==0||s==0)return i==s?null:{a:n,b:r};let o=t.child(--i),l=e.child(--s),a=o.nodeSize;if(o!=l){if(!o.sameMarkup(l))return{a:n,b:r};if(o.isText&&o.text!=l.text){let t=0,e=Math.min(o.text.length,l.text.length);while(t<e&&o.text[o.text.length-t-1]==l.text[l.text.length-t-1]){t++;n--;r--}return{a:n,b:r}}if(o.content.size||l.content.size){let t=findDiffEnd(o.content,l.content,n-1,r-1);if(t)return t}n-=a;r-=a}else{n-=a;r-=a}}}class Fragment{constructor(t,e){this.content=t;this.size=e||0;if(e==null)for(let e=0;e<t.length;e++)this.size+=t[e].nodeSize}nodesBetween(t,e,n,r=0,i){for(let s=0,o=0;o<e;s++){let l=this.content[s],a=o+l.nodeSize;if(a>t&&n(l,r+o,i||null,s)!==false&&l.content.size){let i=o+1;l.nodesBetween(Math.max(0,t-i),Math.min(l.content.size,e-i),n,r+i)}o=a}}descendants(t){this.nodesBetween(0,this.size,t)}textBetween(t,e,n,r){let i="",s=true;this.nodesBetween(t,e,((o,l)=>{let a=o.isText?o.text.slice(Math.max(t,l)-l,e-l):o.isLeaf?r?typeof r==="function"?r(o):r:o.type.spec.leafText?o.type.spec.leafText(o):"":"";o.isBlock&&(o.isLeaf&&a||o.isTextblock)&&n&&(s?s=false:i+=n);i+=a}),0);return i}append(t){if(!t.size)return this;if(!this.size)return t;let e=this.lastChild,n=t.firstChild,r=this.content.slice(),i=0;if(e.isText&&e.sameMarkup(n)){r[r.length-1]=e.withText(e.text+n.text);i=1}for(;i<t.content.length;i++)r.push(t.content[i]);return new Fragment(r,this.size+t.size)}cut(t,e=this.size){if(t==0&&e==this.size)return this;let n=[],r=0;if(e>t)for(let i=0,s=0;s<e;i++){let o=this.content[i],l=s+o.nodeSize;if(l>t){(s<t||l>e)&&(o=o.isText?o.cut(Math.max(0,t-s),Math.min(o.text.length,e-s)):o.cut(Math.max(0,t-s-1),Math.min(o.content.size,e-s-1)));n.push(o);r+=o.nodeSize}s=l}return new Fragment(n,r)}cutByIndex(t,e){return t==e?Fragment.empty:t==0&&e==this.content.length?this:new Fragment(this.content.slice(t,e))}replaceChild(t,e){let n=this.content[t];if(n==e)return this;let r=this.content.slice();let i=this.size+e.nodeSize-n.nodeSize;r[t]=e;return new Fragment(r,i)}addToStart(t){return new Fragment([t].concat(this.content),this.size+t.nodeSize)}addToEnd(t){return new Fragment(this.content.concat(t),this.size+t.nodeSize)}eq(t){if(this.content.length!=t.content.length)return false;for(let e=0;e<this.content.length;e++)if(!this.content[e].eq(t.content[e]))return false;return true}get firstChild(){return this.content.length?this.content[0]:null}get lastChild(){return this.content.length?this.content[this.content.length-1]:null}get childCount(){return this.content.length}child(t){let e=this.content[t];if(!e)throw new RangeError("Index "+t+" out of range for "+this);return e}maybeChild(t){return this.content[t]||null}forEach(t){for(let e=0,n=0;e<this.content.length;e++){let r=this.content[e];t(r,n,e);n+=r.nodeSize}}findDiffStart(t,e=0){return findDiffStart(this,t,e)}findDiffEnd(t,e=this.size,n=t.size){return findDiffEnd(this,t,e,n)}findIndex(t,e=-1){if(t==0)return retIndex(0,t);if(t==this.size)return retIndex(this.content.length,t);if(t>this.size||t<0)throw new RangeError(`Position ${t} outside of fragment (${this})`);for(let n=0,r=0;;n++){let i=this.child(n),s=r+i.nodeSize;if(s>=t)return s==t||e>0?retIndex(n+1,s):retIndex(n,r);r=s}}toString(){return"<"+this.toStringInner()+">"}toStringInner(){return this.content.join(", ")}toJSON(){return this.content.length?this.content.map((t=>t.toJSON())):null}static fromJSON(t,e){if(!e)return Fragment.empty;if(!Array.isArray(e))throw new RangeError("Invalid input for Fragment.fromJSON");return new Fragment(e.map(t.nodeFromJSON))}static fromArray(t){if(!t.length)return Fragment.empty;let e,n=0;for(let r=0;r<t.length;r++){let i=t[r];n+=i.nodeSize;if(r&&i.isText&&t[r-1].sameMarkup(i)){e||(e=t.slice(0,r));e[e.length-1]=i.withText(e[e.length-1].text+i.text)}else e&&e.push(i)}return new Fragment(e||t,n)}static from(t){if(!t)return Fragment.empty;if(t instanceof Fragment)return t;if(Array.isArray(t))return this.fromArray(t);if(t.attrs)return new Fragment([t],t.nodeSize);throw new RangeError("Can not convert "+t+" to a Fragment"+(t.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}}Fragment.empty=new Fragment([],0);const e={index:0,offset:0};function retIndex(t,n){e.index=t;e.offset=n;return e}function compareDeep(t,e){if(t===e)return true;if(!(t&&typeof t=="object")||!(e&&typeof e=="object"))return false;let n=Array.isArray(t);if(Array.isArray(e)!=n)return false;if(n){if(t.length!=e.length)return false;for(let n=0;n<t.length;n++)if(!compareDeep(t[n],e[n]))return false}else{for(let n in t)if(!(n in e)||!compareDeep(t[n],e[n]))return false;for(let n in e)if(!(n in t))return false}return true}class Mark{constructor(t,e){this.type=t;this.attrs=e}addToSet(t){let e,n=false;for(let r=0;r<t.length;r++){let i=t[r];if(this.eq(i))return t;if(this.type.excludes(i.type))e||(e=t.slice(0,r));else{if(i.type.excludes(this.type))return t;if(!n&&i.type.rank>this.type.rank){e||(e=t.slice(0,r));e.push(this);n=true}e&&e.push(i)}}e||(e=t.slice());n||e.push(this);return e}removeFromSet(t){for(let e=0;e<t.length;e++)if(this.eq(t[e]))return t.slice(0,e).concat(t.slice(e+1));return t}isInSet(t){for(let e=0;e<t.length;e++)if(this.eq(t[e]))return true;return false}eq(t){return this==t||this.type==t.type&&compareDeep(this.attrs,t.attrs)}toJSON(){let t={type:this.type.name};for(let e in this.attrs){t.attrs=this.attrs;break}return t}static fromJSON(t,e){if(!e)throw new RangeError("Invalid input for Mark.fromJSON");let n=t.marks[e.type];if(!n)throw new RangeError(`There is no mark type ${e.type} in this schema`);let r=n.create(e.attrs);n.checkAttrs(r.attrs);return r}static sameSet(t,e){if(t==e)return true;if(t.length!=e.length)return false;for(let n=0;n<t.length;n++)if(!t[n].eq(e[n]))return false;return true}static setFrom(t){if(!t||Array.isArray(t)&&t.length==0)return Mark.none;if(t instanceof Mark)return[t];let e=t.slice();e.sort(((t,e)=>t.type.rank-e.type.rank));return e}}Mark.none=[];class ReplaceError extends Error{}class Slice{constructor(t,e,n){this.content=t;this.openStart=e;this.openEnd=n}get size(){return this.content.size-this.openStart-this.openEnd}insertAt(t,e){let n=insertInto(this.content,t+this.openStart,e);return n&&new Slice(n,this.openStart,this.openEnd)}removeBetween(t,e){return new Slice(removeRange(this.content,t+this.openStart,e+this.openStart),this.openStart,this.openEnd)}eq(t){return this.content.eq(t.content)&&this.openStart==t.openStart&&this.openEnd==t.openEnd}toString(){return this.content+"("+this.openStart+","+this.openEnd+")"}toJSON(){if(!this.content.size)return null;let t={content:this.content.toJSON()};this.openStart>0&&(t.openStart=this.openStart);this.openEnd>0&&(t.openEnd=this.openEnd);return t}static fromJSON(t,e){if(!e)return Slice.empty;let n=e.openStart||0,r=e.openEnd||0;if(typeof n!="number"||typeof r!="number")throw new RangeError("Invalid input for Slice.fromJSON");return new Slice(Fragment.fromJSON(t,e.content),n,r)}static maxOpen(t,e=true){let n=0,r=0;for(let r=t.firstChild;r&&!r.isLeaf&&(e||!r.type.spec.isolating);r=r.firstChild)n++;for(let n=t.lastChild;n&&!n.isLeaf&&(e||!n.type.spec.isolating);n=n.lastChild)r++;return new Slice(t,n,r)}}Slice.empty=new Slice(Fragment.empty,0,0);function removeRange(t,e,n){let{index:r,offset:i}=t.findIndex(e),s=t.maybeChild(r);let{index:o,offset:l}=t.findIndex(n);if(i==e||s.isText){if(l!=n&&!t.child(o).isText)throw new RangeError("Removing non-flat range");return t.cut(0,e).append(t.cut(n))}if(r!=o)throw new RangeError("Removing non-flat range");return t.replaceChild(r,s.copy(removeRange(s.content,e-i-1,n-i-1)))}function insertInto(t,e,n,r){let{index:i,offset:s}=t.findIndex(e),o=t.maybeChild(i);if(s==e||o.isText)return r&&!r.canReplace(i,i,n)?null:t.cut(0,e).append(n).append(t.cut(e));let l=insertInto(o.content,e-s-1,n);return l&&t.replaceChild(i,o.copy(l))}function replace(t,e,n){if(n.openStart>t.depth)throw new ReplaceError("Inserted content deeper than insertion position");if(t.depth-n.openStart!=e.depth-n.openEnd)throw new ReplaceError("Inconsistent open depths");return replaceOuter(t,e,n,0)}function replaceOuter(t,e,n,r){let i=t.index(r),s=t.node(r);if(i==e.index(r)&&r<t.depth-n.openStart){let o=replaceOuter(t,e,n,r+1);return s.copy(s.content.replaceChild(i,o))}if(n.content.size){if(n.openStart||n.openEnd||t.depth!=r||e.depth!=r){let{start:i,end:o}=prepareSliceForReplace(n,t);return close(s,replaceThreeWay(t,i,o,e,r))}{let r=t.parent,i=r.content;return close(r,i.cut(0,t.parentOffset).append(n.content).append(i.cut(e.parentOffset)))}}return close(s,replaceTwoWay(t,e,r))}function checkJoin(t,e){if(!e.type.compatibleContent(t.type))throw new ReplaceError("Cannot join "+e.type.name+" onto "+t.type.name)}function joinable(t,e,n){let r=t.node(n);checkJoin(r,e.node(n));return r}function addNode(t,e){let n=e.length-1;n>=0&&t.isText&&t.sameMarkup(e[n])?e[n]=t.withText(e[n].text+t.text):e.push(t)}function addRange(t,e,n,r){let i=(e||t).node(n);let s=0,o=e?e.index(n):i.childCount;if(t){s=t.index(n);if(t.depth>n)s++;else if(t.textOffset){addNode(t.nodeAfter,r);s++}}for(let t=s;t<o;t++)addNode(i.child(t),r);e&&e.depth==n&&e.textOffset&&addNode(e.nodeBefore,r)}function close(t,e){t.type.checkContent(e);return t.copy(e)}function replaceThreeWay(t,e,n,r,i){let s=t.depth>i&&joinable(t,e,i+1);let o=r.depth>i&&joinable(n,r,i+1);let l=[];addRange(null,t,i,l);if(s&&o&&e.index(i)==n.index(i)){checkJoin(s,o);addNode(close(s,replaceThreeWay(t,e,n,r,i+1)),l)}else{s&&addNode(close(s,replaceTwoWay(t,e,i+1)),l);addRange(e,n,i,l);o&&addNode(close(o,replaceTwoWay(n,r,i+1)),l)}addRange(r,null,i,l);return new Fragment(l)}function replaceTwoWay(t,e,n){let r=[];addRange(null,t,n,r);if(t.depth>n){let i=joinable(t,e,n+1);addNode(close(i,replaceTwoWay(t,e,n+1)),r)}addRange(e,null,n,r);return new Fragment(r)}function prepareSliceForReplace(t,e){let n=e.depth-t.openStart,r=e.node(n);let i=r.copy(t.content);for(let t=n-1;t>=0;t--)i=e.node(t).copy(Fragment.from(i));return{start:i.resolveNoCache(t.openStart+n),end:i.resolveNoCache(i.content.size-t.openEnd-n)}}class ResolvedPos{constructor(t,e,n){this.pos=t;this.path=e;this.parentOffset=n;this.depth=e.length/3-1}resolveDepth(t){return t==null?this.depth:t<0?this.depth+t:t}get parent(){return this.node(this.depth)}get doc(){return this.node(0)}node(t){return this.path[this.resolveDepth(t)*3]}index(t){return this.path[this.resolveDepth(t)*3+1]}indexAfter(t){t=this.resolveDepth(t);return this.index(t)+(t!=this.depth||this.textOffset?1:0)}start(t){t=this.resolveDepth(t);return t==0?0:this.path[t*3-1]+1}end(t){t=this.resolveDepth(t);return this.start(t)+this.node(t).content.size}before(t){t=this.resolveDepth(t);if(!t)throw new RangeError("There is no position before the top-level node");return t==this.depth+1?this.pos:this.path[t*3-1]}after(t){t=this.resolveDepth(t);if(!t)throw new RangeError("There is no position after the top-level node");return t==this.depth+1?this.pos:this.path[t*3-1]+this.path[t*3].nodeSize}get textOffset(){return this.pos-this.path[this.path.length-1]}get nodeAfter(){let t=this.parent,e=this.index(this.depth);if(e==t.childCount)return null;let n=this.pos-this.path[this.path.length-1],r=t.child(e);return n?t.child(e).cut(n):r}get nodeBefore(){let t=this.index(this.depth);let e=this.pos-this.path[this.path.length-1];return e?this.parent.child(t).cut(0,e):t==0?null:this.parent.child(t-1)}posAtIndex(t,e){e=this.resolveDepth(e);let n=this.path[e*3],r=e==0?0:this.path[e*3-1]+1;for(let e=0;e<t;e++)r+=n.child(e).nodeSize;return r}marks(){let t=this.parent,e=this.index();if(t.content.size==0)return Mark.none;if(this.textOffset)return t.child(e).marks;let n=t.maybeChild(e-1),r=t.maybeChild(e);if(!n){let t=n;n=r;r=t}let i=n.marks;for(var s=0;s<i.length;s++)i[s].type.spec.inclusive!==false||r&&i[s].isInSet(r.marks)||(i=i[s--].removeFromSet(i));return i}marksAcross(t){let e=this.parent.maybeChild(this.index());if(!e||!e.isInline)return null;let n=e.marks,r=t.parent.maybeChild(t.index());for(var i=0;i<n.length;i++)n[i].type.spec.inclusive!==false||r&&n[i].isInSet(r.marks)||(n=n[i--].removeFromSet(n));return n}sharedDepth(t){for(let e=this.depth;e>0;e--)if(this.start(e)<=t&&this.end(e)>=t)return e;return 0}blockRange(t=this,e){if(t.pos<this.pos)return t.blockRange(this);for(let n=this.depth-(this.parent.inlineContent||this.pos==t.pos?1:0);n>=0;n--)if(t.pos<=this.end(n)&&(!e||e(this.node(n))))return new NodeRange(this,t,n);return null}sameParent(t){return this.pos-this.parentOffset==t.pos-t.parentOffset}max(t){return t.pos>this.pos?t:this}min(t){return t.pos<this.pos?t:this}toString(){let t="";for(let e=1;e<=this.depth;e++)t+=(t?"/":"")+this.node(e).type.name+"_"+this.index(e-1);return t+":"+this.parentOffset}static resolve(t,e){if(!(e>=0&&e<=t.content.size))throw new RangeError("Position "+e+" out of range");let n=[];let r=0,i=e;for(let e=t;;){let{index:t,offset:s}=e.content.findIndex(i);let o=i-s;n.push(e,t,r+s);if(!o)break;e=e.child(t);if(e.isText)break;i=o-1;r+=s+1}return new ResolvedPos(e,n,i)}static resolveCached(t,e){let i=r.get(t);if(i)for(let t=0;t<i.elts.length;t++){let n=i.elts[t];if(n.pos==e)return n}else r.set(t,i=new ResolveCache);let s=i.elts[i.i]=ResolvedPos.resolve(t,e);i.i=(i.i+1)%n;return s}}class ResolveCache{constructor(){this.elts=[];this.i=0}}const n=12,r=new WeakMap;class NodeRange{constructor(t,e,n){this.$from=t;this.$to=e;this.depth=n}get start(){return this.$from.before(this.depth+1)}get end(){return this.$to.after(this.depth+1)}get parent(){return this.$from.node(this.depth)}get startIndex(){return this.$from.index(this.depth)}get endIndex(){return this.$to.indexAfter(this.depth)}}const i=Object.create(null);class Node{constructor(t,e,n,r=Mark.none){this.type=t;this.attrs=e;this.marks=r;this.content=n||Fragment.empty}get children(){return this.content.content}get nodeSize(){return this.isLeaf?1:2+this.content.size}get childCount(){return this.content.childCount}child(t){return this.content.child(t)}maybeChild(t){return this.content.maybeChild(t)}forEach(t){this.content.forEach(t)}nodesBetween(t,e,n,r=0){this.content.nodesBetween(t,e,n,r,this)}descendants(t){this.nodesBetween(0,this.content.size,t)}get textContent(){return this.isLeaf&&this.type.spec.leafText?this.type.spec.leafText(this):this.textBetween(0,this.content.size,"")}textBetween(t,e,n,r){return this.content.textBetween(t,e,n,r)}get firstChild(){return this.content.firstChild}get lastChild(){return this.content.lastChild}eq(t){return this==t||this.sameMarkup(t)&&this.content.eq(t.content)}sameMarkup(t){return this.hasMarkup(t.type,t.attrs,t.marks)}hasMarkup(t,e,n){return this.type==t&&compareDeep(this.attrs,e||t.defaultAttrs||i)&&Mark.sameSet(this.marks,n||Mark.none)}copy(t=null){return t==this.content?this:new Node(this.type,this.attrs,t,this.marks)}mark(t){return t==this.marks?this:new Node(this.type,this.attrs,this.content,t)}cut(t,e=this.content.size){return t==0&&e==this.content.size?this:this.copy(this.content.cut(t,e))}slice(t,e=this.content.size,n=false){if(t==e)return Slice.empty;let r=this.resolve(t),i=this.resolve(e);let s=n?0:r.sharedDepth(e);let o=r.start(s),l=r.node(s);let a=l.content.cut(r.pos-o,i.pos-o);return new Slice(a,r.depth-s,i.depth-s)}replace(t,e,n){return replace(this.resolve(t),this.resolve(e),n)}nodeAt(t){for(let e=this;;){let{index:n,offset:r}=e.content.findIndex(t);e=e.maybeChild(n);if(!e)return null;if(r==t||e.isText)return e;t-=r+1}}childAfter(t){let{index:e,offset:n}=this.content.findIndex(t);return{node:this.content.maybeChild(e),index:e,offset:n}}childBefore(t){if(t==0)return{node:null,index:0,offset:0};let{index:e,offset:n}=this.content.findIndex(t);if(n<t)return{node:this.content.child(e),index:e,offset:n};let r=this.content.child(e-1);return{node:r,index:e-1,offset:n-r.nodeSize}}resolve(t){return ResolvedPos.resolveCached(this,t)}resolveNoCache(t){return ResolvedPos.resolve(this,t)}rangeHasMark(t,e,n){let r=false;e>t&&this.nodesBetween(t,e,(t=>{n.isInSet(t.marks)&&(r=true);return!r}));return r}get isBlock(){return this.type.isBlock}get isTextblock(){return this.type.isTextblock}get inlineContent(){return this.type.inlineContent}get isInline(){return this.type.isInline}get isText(){return this.type.isText}get isLeaf(){return this.type.isLeaf}get isAtom(){return this.type.isAtom}toString(){if(this.type.spec.toDebugString)return this.type.spec.toDebugString(this);let t=this.type.name;this.content.size&&(t+="("+this.content.toStringInner()+")");return wrapMarks(this.marks,t)}contentMatchAt(t){let e=this.type.contentMatch.matchFragment(this.content,0,t);if(!e)throw new Error("Called contentMatchAt on a node with invalid content");return e}canReplace(t,e,n=Fragment.empty,r=0,i=n.childCount){let s=this.contentMatchAt(t).matchFragment(n,r,i);let o=s&&s.matchFragment(this.content,e);if(!o||!o.validEnd)return false;for(let t=r;t<i;t++)if(!this.type.allowsMarks(n.child(t).marks))return false;return true}canReplaceWith(t,e,n,r){if(r&&!this.type.allowsMarks(r))return false;let i=this.contentMatchAt(t).matchType(n);let s=i&&i.matchFragment(this.content,e);return!!s&&s.validEnd}canAppend(t){return t.content.size?this.canReplace(this.childCount,this.childCount,t.content):this.type.compatibleContent(t.type)}check(){this.type.checkContent(this.content);this.type.checkAttrs(this.attrs);let t=Mark.none;for(let e=0;e<this.marks.length;e++){let n=this.marks[e];n.type.checkAttrs(n.attrs);t=n.addToSet(t)}if(!Mark.sameSet(t,this.marks))throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t=>t.type.name))}`);this.content.forEach((t=>t.check()))}toJSON(){let t={type:this.type.name};for(let e in this.attrs){t.attrs=this.attrs;break}this.content.size&&(t.content=this.content.toJSON());this.marks.length&&(t.marks=this.marks.map((t=>t.toJSON())));return t}static fromJSON(t,e){if(!e)throw new RangeError("Invalid input for Node.fromJSON");let n;if(e.marks){if(!Array.isArray(e.marks))throw new RangeError("Invalid mark data for Node.fromJSON");n=e.marks.map(t.markFromJSON)}if(e.type=="text"){if(typeof e.text!="string")throw new RangeError("Invalid text node in JSON");return t.text(e.text,n)}let r=Fragment.fromJSON(t,e.content);let i=t.nodeType(e.type).create(e.attrs,r,n);i.type.checkAttrs(i.attrs);return i}}Node.prototype.text=void 0;class TextNode extends Node{constructor(t,e,n,r){super(t,e,null,r);if(!n)throw new RangeError("Empty text nodes are not allowed");this.text=n}toString(){return this.type.spec.toDebugString?this.type.spec.toDebugString(this):wrapMarks(this.marks,JSON.stringify(this.text))}get textContent(){return this.text}textBetween(t,e){return this.text.slice(t,e)}get nodeSize(){return this.text.length}mark(t){return t==this.marks?this:new TextNode(this.type,this.attrs,this.text,t)}withText(t){return t==this.text?this:new TextNode(this.type,this.attrs,t,this.marks)}cut(t=0,e=this.text.length){return t==0&&e==this.text.length?this:this.withText(this.text.slice(t,e))}eq(t){return this.sameMarkup(t)&&this.text==t.text}toJSON(){let t=super.toJSON();t.text=this.text;return t}}function wrapMarks(t,e){for(let n=t.length-1;n>=0;n--)e=t[n].type.name+"("+e+")";return e}class ContentMatch{constructor(t){this.validEnd=t;this.next=[];this.wrapCache=[]}static parse(t,e){let n=new TokenStream(t,e);if(n.next==null)return ContentMatch.empty;let r=parseExpr(n);n.next&&n.err("Unexpected trailing text");let i=dfa(nfa(r));checkForDeadEnds(i,n);return i}matchType(t){for(let e=0;e<this.next.length;e++)if(this.next[e].type==t)return this.next[e].next;return null}matchFragment(t,e=0,n=t.childCount){let r=this;for(let i=e;r&&i<n;i++)r=r.matchType(t.child(i).type);return r}get inlineContent(){return this.next.length!=0&&this.next[0].type.isInline}get defaultType(){for(let t=0;t<this.next.length;t++){let{type:e}=this.next[t];if(!(e.isText||e.hasRequiredAttrs()))return e}return null}compatible(t){for(let e=0;e<this.next.length;e++)for(let n=0;n<t.next.length;n++)if(this.next[e].type==t.next[n].type)return true;return false}fillBefore(t,e=false,n=0){let r=[this];function search(i,s){let o=i.matchFragment(t,n);if(o&&(!e||o.validEnd))return Fragment.from(s.map((t=>t.createAndFill())));for(let t=0;t<i.next.length;t++){let{type:e,next:n}=i.next[t];if(!(e.isText||e.hasRequiredAttrs())&&r.indexOf(n)==-1){r.push(n);let t=search(n,s.concat(e));if(t)return t}}return null}return search(this,[])}findWrapping(t){for(let e=0;e<this.wrapCache.length;e+=2)if(this.wrapCache[e]==t)return this.wrapCache[e+1];let e=this.computeWrapping(t);this.wrapCache.push(t,e);return e}computeWrapping(t){let e=Object.create(null),n=[{match:this,type:null,via:null}];while(n.length){let r=n.shift(),i=r.match;if(i.matchType(t)){let t=[];for(let e=r;e.type;e=e.via)t.push(e.type);return t.reverse()}for(let t=0;t<i.next.length;t++){let{type:s,next:o}=i.next[t];if(!s.isLeaf&&!s.hasRequiredAttrs()&&!(s.name in e)&&(!r.type||o.validEnd)){n.push({match:s.contentMatch,type:s,via:r});e[s.name]=true}}}return null}get edgeCount(){return this.next.length}edge(t){if(t>=this.next.length)throw new RangeError(`There's no ${t}th edge in this content match`);return this.next[t]}toString(){let t=[];function scan(e){t.push(e);for(let n=0;n<e.next.length;n++)t.indexOf(e.next[n].next)==-1&&scan(e.next[n].next)}scan(this);return t.map(((e,n)=>{let r=n+(e.validEnd?"*":" ")+" ";for(let n=0;n<e.next.length;n++)r+=(n?", ":"")+e.next[n].type.name+"->"+t.indexOf(e.next[n].next);return r})).join("\n")}}ContentMatch.empty=new ContentMatch(true);class TokenStream{constructor(t,e){this.string=t;this.nodeTypes=e;this.inline=null;this.pos=0;this.tokens=t.split(/\s*(?=\b|\W|$)/);this.tokens[this.tokens.length-1]==""&&this.tokens.pop();this.tokens[0]==""&&this.tokens.shift()}get next(){return this.tokens[this.pos]}eat(t){return this.next==t&&(this.pos++||true)}err(t){throw new SyntaxError(t+" (in content expression '"+this.string+"')")}}function parseExpr(t){let e=[];do{e.push(parseExprSeq(t))}while(t.eat("|"));return e.length==1?e[0]:{type:"choice",exprs:e}}function parseExprSeq(t){let e=[];do{e.push(parseExprSubscript(t))}while(t.next&&t.next!=")"&&t.next!="|");return e.length==1?e[0]:{type:"seq",exprs:e}}function parseExprSubscript(t){let e=parseExprAtom(t);for(;;)if(t.eat("+"))e={type:"plus",expr:e};else if(t.eat("*"))e={type:"star",expr:e};else if(t.eat("?"))e={type:"opt",expr:e};else{if(!t.eat("{"))break;e=parseExprRange(t,e)}return e}function parseNum(t){/\D/.test(t.next)&&t.err("Expected number, got '"+t.next+"'");let e=Number(t.next);t.pos++;return e}function parseExprRange(t,e){let n=parseNum(t),r=n;t.eat(",")&&(r=t.next!="}"?parseNum(t):-1);t.eat("}")||t.err("Unclosed braced range");return{type:"range",min:n,max:r,expr:e}}function resolveName(t,e){let n=t.nodeTypes,r=n[e];if(r)return[r];let i=[];for(let t in n){let r=n[t];r.isInGroup(e)&&i.push(r)}i.length==0&&t.err("No node type or group '"+e+"' found");return i}function parseExprAtom(t){if(t.eat("(")){let e=parseExpr(t);t.eat(")")||t.err("Missing closing paren");return e}if(!/\W/.test(t.next)){let e=resolveName(t,t.next).map((e=>{t.inline==null?t.inline=e.isInline:t.inline!=e.isInline&&t.err("Mixing inline and block content");return{type:"name",value:e}}));t.pos++;return e.length==1?e[0]:{type:"choice",exprs:e}}t.err("Unexpected token '"+t.next+"'")}function nfa(t){let e=[[]];connect(compile(t,0),node());return e;function node(){return e.push([])-1}function edge(t,n,r){let i={term:r,to:n};e[t].push(i);return i}function connect(t,e){t.forEach((t=>t.to=e))}function compile(t,e){if(t.type=="choice")return t.exprs.reduce(((t,n)=>t.concat(compile(n,e))),[]);if(t.type!="seq"){if(t.type=="star"){let n=node();edge(e,n);connect(compile(t.expr,n),n);return[edge(n)]}if(t.type=="plus"){let n=node();connect(compile(t.expr,e),n);connect(compile(t.expr,n),n);return[edge(n)]}if(t.type=="opt")return[edge(e)].concat(compile(t.expr,e));if(t.type=="range"){let n=e;for(let e=0;e<t.min;e++){let e=node();connect(compile(t.expr,n),e);n=e}if(t.max==-1)connect(compile(t.expr,n),n);else for(let e=t.min;e<t.max;e++){let e=node();edge(n,e);connect(compile(t.expr,n),e);n=e}return[edge(n)]}if(t.type=="name")return[edge(e,void 0,t.value)];throw new Error("Unknown expr type")}for(let n=0;;n++){let r=compile(t.exprs[n],e);if(n==t.exprs.length-1)return r;connect(r,e=node())}}}function cmp(t,e){return e-t}function nullFrom(t,e){let n=[];scan(e);return n.sort(cmp);function scan(e){let r=t[e];if(r.length==1&&!r[0].term)return scan(r[0].to);n.push(e);for(let t=0;t<r.length;t++){let{term:e,to:i}=r[t];e||n.indexOf(i)!=-1||scan(i)}}}function dfa(t){let e=Object.create(null);return explore(nullFrom(t,0));function explore(n){let r=[];n.forEach((e=>{t[e].forEach((({term:e,to:n})=>{if(!e)return;let i;for(let t=0;t<r.length;t++)r[t][0]==e&&(i=r[t][1]);nullFrom(t,n).forEach((t=>{i||r.push([e,i=[]]);i.indexOf(t)==-1&&i.push(t)}))}))}));let i=e[n.join(",")]=new ContentMatch(n.indexOf(t.length-1)>-1);for(let t=0;t<r.length;t++){let n=r[t][1].sort(cmp);i.next.push({type:r[t][0],next:e[n.join(",")]||explore(n)})}return i}}function checkForDeadEnds(t,e){for(let n=0,r=[t];n<r.length;n++){let t=r[n],i=!t.validEnd,s=[];for(let e=0;e<t.next.length;e++){let{type:n,next:o}=t.next[e];s.push(n.name);i&&!(n.isText||n.hasRequiredAttrs())&&(i=false);r.indexOf(o)==-1&&r.push(o)}i&&e.err("Only non-generatable nodes ("+s.join(", ")+") in a required position (see https://prosemirror.net/docs/guide/#generatable)")}}function defaultAttrs(t){let e=Object.create(null);for(let n in t){let r=t[n];if(!r.hasDefault)return null;e[n]=r.default}return e}function computeAttrs(t,e){let n=Object.create(null);for(let r in t){let i=e&&e[r];if(i===void 0){let e=t[r];if(!e.hasDefault)throw new RangeError("No value supplied for attribute "+r);i=e.default}n[r]=i}return n}function checkAttrs(t,e,n,r){for(let r in e)if(!(r in t))throw new RangeError(`Unsupported attribute ${r} for ${n} of type ${r}`);for(let n in t){let r=t[n];r.validate&&r.validate(e[n])}}function initAttrs(t,e){let n=Object.create(null);if(e)for(let r in e)n[r]=new Attribute(t,r,e[r]);return n}class NodeType{constructor(t,e,n){this.name=t;this.schema=e;this.spec=n;this.markSet=null;this.groups=n.group?n.group.split(" "):[];this.attrs=initAttrs(t,n.attrs);this.defaultAttrs=defaultAttrs(this.attrs);this.contentMatch=null;this.inlineContent=null;this.isBlock=!(n.inline||t=="text");this.isText=t=="text"}get isInline(){return!this.isBlock}get isTextblock(){return this.isBlock&&this.inlineContent}get isLeaf(){return this.contentMatch==ContentMatch.empty}get isAtom(){return this.isLeaf||!!this.spec.atom}isInGroup(t){return this.groups.indexOf(t)>-1}get whitespace(){return this.spec.whitespace||(this.spec.code?"pre":"normal")}hasRequiredAttrs(){for(let t in this.attrs)if(this.attrs[t].isRequired)return true;return false}compatibleContent(t){return this==t||this.contentMatch.compatible(t.contentMatch)}computeAttrs(t){return!t&&this.defaultAttrs?this.defaultAttrs:computeAttrs(this.attrs,t)}create(t=null,e,n){if(this.isText)throw new Error("NodeType.create can't construct text nodes");return new Node(this,this.computeAttrs(t),Fragment.from(e),Mark.setFrom(n))}createChecked(t=null,e,n){e=Fragment.from(e);this.checkContent(e);return new Node(this,this.computeAttrs(t),e,Mark.setFrom(n))}createAndFill(t=null,e,n){t=this.computeAttrs(t);e=Fragment.from(e);if(e.size){let t=this.contentMatch.fillBefore(e);if(!t)return null;e=t.append(e)}let r=this.contentMatch.matchFragment(e);let i=r&&r.fillBefore(Fragment.empty,true);return i?new Node(this,t,e.append(i),Mark.setFrom(n)):null}validContent(t){let e=this.contentMatch.matchFragment(t);if(!e||!e.validEnd)return false;for(let e=0;e<t.childCount;e++)if(!this.allowsMarks(t.child(e).marks))return false;return true}checkContent(t){if(!this.validContent(t))throw new RangeError(`Invalid content for node ${this.name}: ${t.toString().slice(0,50)}`)}checkAttrs(t){checkAttrs(this.attrs,t,"node",this.name)}allowsMarkType(t){return this.markSet==null||this.markSet.indexOf(t)>-1}allowsMarks(t){if(this.markSet==null)return true;for(let e=0;e<t.length;e++)if(!this.allowsMarkType(t[e].type))return false;return true}allowedMarks(t){if(this.markSet==null)return t;let e;for(let n=0;n<t.length;n++)this.allowsMarkType(t[n].type)?e&&e.push(t[n]):e||(e=t.slice(0,n));return e?e.length?e:Mark.none:t}static compile(t,e){let n=Object.create(null);t.forEach(((t,r)=>n[t]=new NodeType(t,e,r)));let r=e.spec.topNode||"doc";if(!n[r])throw new RangeError("Schema is missing its top node type ('"+r+"')");if(!n.text)throw new RangeError("Every schema needs a 'text' type");for(let t in n.text.attrs)throw new RangeError("The text node type should not have attributes");return n}}function validateType(t,e,n){let r=n.split("|");return n=>{let i=n===null?"null":typeof n;if(r.indexOf(i)<0)throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${i}`)}}class Attribute{constructor(t,e,n){this.hasDefault=Object.prototype.hasOwnProperty.call(n,"default");this.default=n.default;this.validate=typeof n.validate=="string"?validateType(t,e,n.validate):n.validate}get isRequired(){return!this.hasDefault}}class MarkType{constructor(t,e,n,r){this.name=t;this.rank=e;this.schema=n;this.spec=r;this.attrs=initAttrs(t,r.attrs);this.excluded=null;let i=defaultAttrs(this.attrs);this.instance=i?new Mark(this,i):null}create(t=null){return!t&&this.instance?this.instance:new Mark(this,computeAttrs(this.attrs,t))}static compile(t,e){let n=Object.create(null),r=0;t.forEach(((t,i)=>n[t]=new MarkType(t,r++,e,i)));return n}removeFromSet(t){for(var e=0;e<t.length;e++)if(t[e].type==this){t=t.slice(0,e).concat(t.slice(e+1));e--}return t}isInSet(t){for(let e=0;e<t.length;e++)if(t[e].type==this)return t[e]}checkAttrs(t){checkAttrs(this.attrs,t,"mark",this.name)}excludes(t){return this.excluded.indexOf(t)>-1}}class Schema{constructor(e){this.linebreakReplacement=null;this.cached=Object.create(null);let n=this.spec={};for(let t in e)n[t]=e[t];n.nodes=t.from(e.nodes),n.marks=t.from(e.marks||{}),this.nodes=NodeType.compile(this.spec.nodes,this);this.marks=MarkType.compile(this.spec.marks,this);let r=Object.create(null);for(let t in this.nodes){if(t in this.marks)throw new RangeError(t+" can not be both a node and a mark");let e=this.nodes[t],n=e.spec.content||"",i=e.spec.marks;e.contentMatch=r[n]||(r[n]=ContentMatch.parse(n,this.nodes));e.inlineContent=e.contentMatch.inlineContent;if(e.spec.linebreakReplacement){if(this.linebreakReplacement)throw new RangeError("Multiple linebreak nodes defined");if(!e.isInline||!e.isLeaf)throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");this.linebreakReplacement=e}e.markSet=i=="_"?null:i?gatherMarks(this,i.split(" ")):i!=""&&e.inlineContent?null:[]}for(let t in this.marks){let e=this.marks[t],n=e.spec.excludes;e.excluded=n==null?[e]:n==""?[]:gatherMarks(this,n.split(" "))}this.nodeFromJSON=this.nodeFromJSON.bind(this);this.markFromJSON=this.markFromJSON.bind(this);this.topNodeType=this.nodes[this.spec.topNode||"doc"];this.cached.wrappings=Object.create(null)}node(t,e=null,n,r){if(typeof t=="string")t=this.nodeType(t);else{if(!(t instanceof NodeType))throw new RangeError("Invalid node type: "+t);if(t.schema!=this)throw new RangeError("Node type from different schema used ("+t.name+")")}return t.createChecked(e,n,r)}text(t,e){let n=this.nodes.text;return new TextNode(n,n.defaultAttrs,t,Mark.setFrom(e))}mark(t,e){typeof t=="string"&&(t=this.marks[t]);return t.create(e)}nodeFromJSON(t){return Node.fromJSON(this,t)}markFromJSON(t){return Mark.fromJSON(this,t)}nodeType(t){let e=this.nodes[t];if(!e)throw new RangeError("Unknown node type: "+t);return e}}function gatherMarks(t,e){let n=[];for(let r=0;r<e.length;r++){let i=e[r],s=t.marks[i],o=s;if(s)n.push(s);else for(let e in t.marks){let r=t.marks[e];(i=="_"||r.spec.group&&r.spec.group.split(" ").indexOf(i)>-1)&&n.push(o=r)}if(!o)throw new SyntaxError("Unknown mark type: '"+e[r]+"'")}return n}function isTagRule(t){return t.tag!=null}function isStyleRule(t){return t.style!=null}class DOMParser{constructor(t,e){this.schema=t;this.rules=e;this.tags=[];this.styles=[];let n=this.matchedStyles=[];e.forEach((t=>{if(isTagRule(t))this.tags.push(t);else if(isStyleRule(t)){let e=/[^=]*/.exec(t.style)[0];n.indexOf(e)<0&&n.push(e);this.styles.push(t)}}));this.normalizeLists=!this.tags.some((e=>{if(!/^(ul|ol)\b/.test(e.tag)||!e.node)return false;let n=t.nodes[e.node];return n.contentMatch.matchType(n)}))}parse(t,e={}){let n=new ParseContext(this,e,false);n.addAll(t,Mark.none,e.from,e.to);return n.finish()}parseSlice(t,e={}){let n=new ParseContext(this,e,true);n.addAll(t,Mark.none,e.from,e.to);return Slice.maxOpen(n.finish())}matchTag(t,e,n){for(let r=n?this.tags.indexOf(n)+1:0;r<this.tags.length;r++){let n=this.tags[r];if(matches(t,n.tag)&&(n.namespace===void 0||t.namespaceURI==n.namespace)&&(!n.context||e.matchesContext(n.context))){if(n.getAttrs){let e=n.getAttrs(t);if(e===false)continue;n.attrs=e||void 0}return n}}}matchStyle(t,e,n,r){for(let i=r?this.styles.indexOf(r)+1:0;i<this.styles.length;i++){let r=this.styles[i],s=r.style;if(!(s.indexOf(t)!=0||r.context&&!n.matchesContext(r.context)||s.length>t.length&&(s.charCodeAt(t.length)!=61||s.slice(t.length+1)!=e))){if(r.getAttrs){let t=r.getAttrs(e);if(t===false)continue;r.attrs=t||void 0}return r}}}static schemaRules(t){let e=[];function insert(t){let n=t.priority==null?50:t.priority,r=0;for(;r<e.length;r++){let t=e[r],i=t.priority==null?50:t.priority;if(i<n)break}e.splice(r,0,t)}for(let e in t.marks){let n=t.marks[e].spec.parseDOM;n&&n.forEach((t=>{insert(t=copy(t));t.mark||t.ignore||t.clearMark||(t.mark=e)}))}for(let e in t.nodes){let n=t.nodes[e].spec.parseDOM;n&&n.forEach((t=>{insert(t=copy(t));t.node||t.ignore||t.mark||(t.node=e)}))}return e}static fromSchema(t){return t.cached.domParser||(t.cached.domParser=new DOMParser(t,DOMParser.schemaRules(t)))}}const s={address:true,article:true,aside:true,blockquote:true,canvas:true,dd:true,div:true,dl:true,fieldset:true,figcaption:true,figure:true,footer:true,form:true,h1:true,h2:true,h3:true,h4:true,h5:true,h6:true,header:true,hgroup:true,hr:true,li:true,noscript:true,ol:true,output:true,p:true,pre:true,section:true,table:true,tfoot:true,ul:true};const o={head:true,noscript:true,object:true,script:true,style:true,title:true};const l={ol:true,ul:true};const a=1,h=2,c=4;function wsOptionsFor(t,e,n){return e!=null?(e?a:0)|(e==="full"?h:0):t&&t.whitespace=="pre"?a|h:n&~c}class NodeContext{constructor(t,e,n,r,i,s){this.type=t;this.attrs=e;this.marks=n;this.solid=r;this.options=s;this.content=[];this.activeMarks=Mark.none;this.match=i||(s&c?null:t.contentMatch)}findWrapping(t){if(!this.match){if(!this.type)return[];let e=this.type.contentMatch.fillBefore(Fragment.from(t));if(!e){let e,n=this.type.contentMatch;if(e=n.findWrapping(t.type)){this.match=n;return e}return null}this.match=this.type.contentMatch.matchFragment(e)}return this.match.findWrapping(t.type)}finish(t){if(!(this.options&a)){let t,e=this.content[this.content.length-1];if(e&&e.isText&&(t=/[ \t\r\n\u000c]+$/.exec(e.text))){let n=e;e.text.length==t[0].length?this.content.pop():this.content[this.content.length-1]=n.withText(n.text.slice(0,n.text.length-t[0].length))}}let e=Fragment.from(this.content);!t&&this.match&&(e=e.append(this.match.fillBefore(Fragment.empty,true)));return this.type?this.type.create(this.attrs,e,this.marks):e}inlineContext(t){return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:t.parentNode&&!s.hasOwnProperty(t.parentNode.nodeName.toLowerCase())}}class ParseContext{constructor(t,e,n){this.parser=t;this.options=e;this.isOpen=n;this.open=0;this.localPreserveWS=false;let r,i=e.topNode;let s=wsOptionsFor(null,e.preserveWhitespace,0)|(n?c:0);r=i?new NodeContext(i.type,i.attrs,Mark.none,true,e.topMatch||i.type.contentMatch,s):new NodeContext(n?null:t.schema.topNodeType,null,Mark.none,true,null,s);this.nodes=[r];this.find=e.findPositions;this.needsBlock=false}get top(){return this.nodes[this.open]}addDOM(t,e){t.nodeType==3?this.addTextNode(t,e):t.nodeType==1&&this.addElement(t,e)}addTextNode(t,e){let n=t.nodeValue;let r=this.top,i=r.options&h?"full":this.localPreserveWS||(r.options&a)>0;if(i==="full"||r.inlineContext(t)||/[^ \t\r\n\u000c]/.test(n)){if(i)n=i!=="full"?n.replace(/\r?\n|\r/g," "):n.replace(/\r\n?/g,"\n");else{n=n.replace(/[ \t\r\n\u000c]+/g," ");if(/^[ \t\r\n\u000c]/.test(n)&&this.open==this.nodes.length-1){let e=r.content[r.content.length-1];let i=t.previousSibling;(!e||i&&i.nodeName=="BR"||e.isText&&/[ \t\r\n\u000c]$/.test(e.text))&&(n=n.slice(1))}}n&&this.insertNode(this.parser.schema.text(n),e);this.findInText(t)}else this.findInside(t)}addElement(t,e,n){let r=this.localPreserveWS,i=this.top;(t.tagName=="PRE"||/pre/.test(t.style&&t.style.whiteSpace))&&(this.localPreserveWS=true);let a,h=t.nodeName.toLowerCase();l.hasOwnProperty(h)&&this.parser.normalizeLists&&normalizeList(t);let c=this.options.ruleFromNode&&this.options.ruleFromNode(t)||(a=this.parser.matchTag(t,this,n));t:if(c?c.ignore:o.hasOwnProperty(h)){this.findInside(t);this.ignoreFallback(t,e)}else if(!c||c.skip||c.closeParent){c&&c.closeParent?this.open=Math.max(0,this.open-1):c&&c.skip.nodeType&&(t=c.skip);let n,r=this.needsBlock;if(s.hasOwnProperty(h)){if(i.content.length&&i.content[0].isInline&&this.open){this.open--;i=this.top}n=true;i.type||(this.needsBlock=true)}else if(!t.firstChild){this.leafFallback(t,e);break t}let o=c&&c.skip?e:this.readStyles(t,e);o&&this.addAll(t,o);n&&this.sync(i);this.needsBlock=r}else{let n=this.readStyles(t,e);n&&this.addElementByRule(t,c,n,c.consuming===false?a:void 0)}this.localPreserveWS=r}leafFallback(t,e){t.nodeName=="BR"&&this.top.type&&this.top.type.inlineContent&&this.addTextNode(t.ownerDocument.createTextNode("\n"),e)}ignoreFallback(t,e){t.nodeName!="BR"||this.top.type&&this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"),e)}readStyles(t,e){let n=t.style;if(n&&n.length)for(let t=0;t<this.parser.matchedStyles.length;t++){let r=this.parser.matchedStyles[t],i=n.getPropertyValue(r);if(i)for(let t;;){let n=this.parser.matchStyle(r,i,this,t);if(!n)break;if(n.ignore)return null;e=n.clearMark?e.filter((t=>!n.clearMark(t))):e.concat(this.parser.schema.marks[n.mark].create(n.attrs));if(n.consuming!==false)break;t=n}}return e}addElementByRule(t,e,n,r){let i,s;if(e.node){s=this.parser.schema.nodes[e.node];if(s.isLeaf)this.insertNode(s.create(e.attrs),n)||this.leafFallback(t,n);else{let t=this.enter(s,e.attrs||null,n,e.preserveWhitespace);if(t){i=true;n=t}}}else{let t=this.parser.schema.marks[e.mark];n=n.concat(t.create(e.attrs))}let o=this.top;if(s&&s.isLeaf)this.findInside(t);else if(r)this.addElement(t,n,r);else if(e.getContent){this.findInside(t);e.getContent(t,this.parser.schema).forEach((t=>this.insertNode(t,n)))}else{let r=t;typeof e.contentElement=="string"?r=t.querySelector(e.contentElement):typeof e.contentElement=="function"?r=e.contentElement(t):e.contentElement&&(r=e.contentElement);this.findAround(t,r,true);this.addAll(r,n);this.findAround(t,r,false)}i&&this.sync(o)&&this.open--}addAll(t,e,n,r){let i=n||0;for(let s=n?t.childNodes[n]:t.firstChild,o=r==null?null:t.childNodes[r];s!=o;s=s.nextSibling,++i){this.findAtPoint(t,i);this.addDOM(s,e)}this.findAtPoint(t,i)}findPlace(t,e){let n,r;for(let e=this.open;e>=0;e--){let i=this.nodes[e];let s=i.findWrapping(t);if(s&&(!n||n.length>s.length)){n=s;r=i;if(!s.length)break}if(i.solid)break}if(!n)return null;this.sync(r);for(let t=0;t<n.length;t++)e=this.enterInner(n[t],null,e,false);return e}insertNode(t,e){if(t.isInline&&this.needsBlock&&!this.top.type){let t=this.textblockFromContext();t&&(e=this.enterInner(t,null,e))}let n=this.findPlace(t,e);if(n){this.closeExtra();let e=this.top;e.match&&(e.match=e.match.matchType(t.type));let r=Mark.none;for(let i of n.concat(t.marks))(e.type?e.type.allowsMarkType(i.type):markMayApply(i.type,t.type))&&(r=i.addToSet(r));e.content.push(t.mark(r));return true}return false}enter(t,e,n,r){let i=this.findPlace(t.create(e),n);i&&(i=this.enterInner(t,e,n,true,r));return i}enterInner(t,e,n,r=false,i){this.closeExtra();let s=this.top;s.match=s.match&&s.match.matchType(t);let o=wsOptionsFor(t,i,s.options);s.options&c&&s.content.length==0&&(o|=c);let l=Mark.none;n=n.filter((e=>{if(s.type?s.type.allowsMarkType(e.type):markMayApply(e.type,t)){l=e.addToSet(l);return false}return true}));this.nodes.push(new NodeContext(t,e,l,r,null,o));this.open++;return n}closeExtra(t=false){let e=this.nodes.length-1;if(e>this.open){for(;e>this.open;e--)this.nodes[e-1].content.push(this.nodes[e].finish(t));this.nodes.length=this.open+1}}finish(){this.open=0;this.closeExtra(this.isOpen);return this.nodes[0].finish(!!(this.isOpen||this.options.topOpen))}sync(t){for(let e=this.open;e>=0;e--){if(this.nodes[e]==t){this.open=e;return true}this.localPreserveWS&&(this.nodes[e].options|=a)}return false}get currentPos(){this.closeExtra();let t=0;for(let e=this.open;e>=0;e--){let n=this.nodes[e].content;for(let e=n.length-1;e>=0;e--)t+=n[e].nodeSize;e&&t++}return t}findAtPoint(t,e){if(this.find)for(let n=0;n<this.find.length;n++)this.find[n].node==t&&this.find[n].offset==e&&(this.find[n].pos=this.currentPos)}findInside(t){if(this.find)for(let e=0;e<this.find.length;e++)this.find[e].pos==null&&t.nodeType==1&&t.contains(this.find[e].node)&&(this.find[e].pos=this.currentPos)}findAround(t,e,n){if(t!=e&&this.find)for(let r=0;r<this.find.length;r++)if(this.find[r].pos==null&&t.nodeType==1&&t.contains(this.find[r].node)){let t=e.compareDocumentPosition(this.find[r].node);t&(n?2:4)&&(this.find[r].pos=this.currentPos)}}findInText(t){if(this.find)for(let e=0;e<this.find.length;e++)this.find[e].node==t&&(this.find[e].pos=this.currentPos-(t.nodeValue.length-this.find[e].offset))}matchesContext(t){if(t.indexOf("|")>-1)return t.split(/\s*\|\s*/).some(this.matchesContext,this);let e=t.split("/");let n=this.options.context;let r=!this.isOpen&&(!n||n.parent.type==this.nodes[0].type);let i=-(n?n.depth+1:0)+(r?0:1);let match=(t,s)=>{for(;t>=0;t--){let o=e[t];if(o==""){if(t==e.length-1||t==0)continue;for(;s>=i;s--)if(match(t-1,s))return true;return false}{let t=s>0||s==0&&r?this.nodes[s].type:n&&s>=i?n.node(s-i).type:null;if(!t||t.name!=o&&!t.isInGroup(o))return false;s--}}return true};return match(e.length-1,this.open)}textblockFromContext(){let t=this.options.context;if(t)for(let e=t.depth;e>=0;e--){let n=t.node(e).contentMatchAt(t.indexAfter(e)).defaultType;if(n&&n.isTextblock&&n.defaultAttrs)return n}for(let t in this.parser.schema.nodes){let e=this.parser.schema.nodes[t];if(e.isTextblock&&e.defaultAttrs)return e}}}function normalizeList(t){for(let e=t.firstChild,n=null;e;e=e.nextSibling){let t=e.nodeType==1?e.nodeName.toLowerCase():null;if(t&&l.hasOwnProperty(t)&&n){n.appendChild(e);e=n}else t=="li"?n=e:t&&(n=null)}}function matches(t,e){return(t.matches||t.msMatchesSelector||t.webkitMatchesSelector||t.mozMatchesSelector).call(t,e)}function copy(t){let e={};for(let n in t)e[n]=t[n];return e}function markMayApply(t,e){let n=e.schema.nodes;for(let r in n){let i=n[r];if(!i.allowsMarkType(t))continue;let s=[],scan=t=>{s.push(t);for(let n=0;n<t.edgeCount;n++){let{type:r,next:i}=t.edge(n);if(r==e)return true;if(s.indexOf(i)<0&&scan(i))return true}};if(scan(i.contentMatch))return true}}class DOMSerializer{constructor(t,e){this.nodes=t;this.marks=e}serializeFragment(t,e={},n){n||(n=doc(e).createDocumentFragment());let r=n,i=[];t.forEach((t=>{if(i.length||t.marks.length){let n=0,s=0;while(n<i.length&&s<t.marks.length){let e=t.marks[s];if(this.marks[e.type.name]){if(!e.eq(i[n][0])||e.type.spec.spanning===false)break;n++;s++}else s++}while(n<i.length)r=i.pop()[1];while(s<t.marks.length){let n=t.marks[s++];let o=this.serializeMark(n,t.isInline,e);if(o){i.push([n,r]);r.appendChild(o.dom);r=o.contentDOM||o.dom}}}r.appendChild(this.serializeNodeInner(t,e))}));return n}serializeNodeInner(t,e){let{dom:n,contentDOM:r}=renderSpec(doc(e),this.nodes[t.type.name](t),null,t.attrs);if(r){if(t.isLeaf)throw new RangeError("Content hole not allowed in a leaf node spec");this.serializeFragment(t.content,e,r)}return n}serializeNode(t,e={}){let n=this.serializeNodeInner(t,e);for(let r=t.marks.length-1;r>=0;r--){let i=this.serializeMark(t.marks[r],t.isInline,e);if(i){(i.contentDOM||i.dom).appendChild(n);n=i.dom}}return n}serializeMark(t,e,n={}){let r=this.marks[t.type.name];return r&&renderSpec(doc(n),r(t,e),null,t.attrs)}static renderSpec(t,e,n=null,r){return renderSpec(t,e,n,r)}static fromSchema(t){return t.cached.domSerializer||(t.cached.domSerializer=new DOMSerializer(this.nodesFromSchema(t),this.marksFromSchema(t)))}static nodesFromSchema(t){let e=gatherToDOM(t.nodes);e.text||(e.text=t=>t.text);return e}static marksFromSchema(t){return gatherToDOM(t.marks)}}function gatherToDOM(t){let e={};for(let n in t){let r=t[n].spec.toDOM;r&&(e[n]=r)}return e}function doc(t){return t.document||window.document}const p=new WeakMap;function suspiciousAttributes(t){let e=p.get(t);e===void 0&&p.set(t,e=suspiciousAttributesInner(t));return e}function suspiciousAttributesInner(t){let e=null;function scan(t){if(t&&typeof t=="object")if(Array.isArray(t))if(typeof t[0]=="string"){e||(e=[]);e.push(t)}else for(let e=0;e<t.length;e++)scan(t[e]);else for(let e in t)scan(t[e])}scan(t);return e}function renderSpec(t,e,n,r){if(typeof e=="string")return{dom:t.createTextNode(e)};if(e.nodeType!=null)return{dom:e};if(e.dom&&e.dom.nodeType!=null)return e;let i,s=e[0];if(typeof s!="string")throw new RangeError("Invalid array passed to renderSpec");if(r&&(i=suspiciousAttributes(r))&&i.indexOf(e)>-1)throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");let o=s.indexOf(" ");if(o>0){n=s.slice(0,o);s=s.slice(o+1)}let l;let a=n?t.createElementNS(n,s):t.createElement(s);let h=e[1],c=1;if(h&&typeof h=="object"&&h.nodeType==null&&!Array.isArray(h)){c=2;for(let t in h)if(h[t]!=null){let e=t.indexOf(" ");e>0?a.setAttributeNS(t.slice(0,e),t.slice(e+1),h[t]):a.setAttribute(t,h[t])}}for(let i=c;i<e.length;i++){let s=e[i];if(s===0){if(i<e.length-1||i>c)throw new RangeError("Content hole must be the only child of its parent node");return{dom:a,contentDOM:a}}{let{dom:e,contentDOM:i}=renderSpec(t,s,n,r);a.appendChild(e);if(i){if(l)throw new RangeError("Multiple content holes");l=i}}}return{dom:a,contentDOM:l}}export{ContentMatch,DOMParser,DOMSerializer,Fragment,Mark,MarkType,Node,NodeRange,NodeType,ReplaceError,ResolvedPos,Schema,Slice};

